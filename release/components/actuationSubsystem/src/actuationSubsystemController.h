 /** @file actuationSubsystemController.h 
  *
  * Version 1.0
  * 
  * Generated by YarpGenerator, Emmanuel Senft, PLYM
  *
  *
  * \defgroup DREAM_actuationSubsystem actuationSubsystem
  * 
  * Main class with code, use the yarpInterface class to communicate with the other components.
  * 
  * \section lib_sec Libraries
  *
  * None
  *
  * \section in_files_sec Input Data Files
  *
  * None
  *
  * \section out_data_sec Output Data Files
  *
  * None
  *
  * \author 
  * 
  * <James Kennedy>, <Plymouth University>  
  * 
  * Copyright (C) 2014 DREAM Consortium
  * 
  */

/* 
 * Copyright (C) 2014 DREAM Consortium
 * FP7 Project 611391 co-funded by the European Commission
 *
 * Author:  James Kennedy, Plymouth University 
 * Email:   james.kennedy@plymouth.ac.uk 
 * Website: www.dream2020.eu 
 * 
 * This file is part of DREAM.
 * 
 * DREAM is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * DREAM is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DREAM.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 /* 
  * Audit Trail
  * -----------
  * 20/09/2016 Version 1.0: ... (James Kennedy)
  */ 
 
#ifndef ACTUATIONSUBSYSTEMCONTROLLER
#define ACTUATIONSUBSYSTEMCONTROLLER

#include <vector>
#include "actionMessages.h"

//Constants in meters
const float _SCREEN_LENGTH_ = 0.3362f;
const float _SCREEN_WIDTH_ = 0.5977f;
const int _SCREEN_RESOLUTION_X_ = 1920;
const int _SCREEN_RESOLUTION_Y_ = 1080;
const float _DISTANCE_ROBOT_SCREEN_X_ = 0.40f;
const float _SCREEN_HEIGHT_ = 0.10f;

class ActuationSubsystemYarpInterface;
class Waiter;
class ActionWaiter;
class SandtrayWaiter;
class SensorWaiter;
class CommonFunctionalities;

class ActuationSubsystemController{
private:
	ActuationSubsystemYarpInterface* _yarpInterface;
public:
	/* class methods */
	ActuationSubsystemController(ActuationSubsystemYarpInterface *yarpInterface);
	void getFromSelectedAction(int stepId, int actionId, std::string arg);
	void getFromMotorFeedback(int stepId, int actionId, int fbValue, int parameter);
	void getFromSensorFeedback(std::string name, bool value);
	void getFromEyeBlinking(int repetitions, bool fullLeds, int duration);
	void getFromInterruption(bool interrupted);
	void getFromElicitedAttention(double x, double y, double z);
	void getFromFallingReaction(int fallingReaction);
	void getFromFallingReactionSpeech(int fallingReactionSpeech);
	void getFromSocialFacialExpression(int socialFacialReaction);
	void getFromSocialReaction(int socialReaction);
	void getFromSocialReactionSpeech(int socialReactionSpeech);
	void say(int stepId, std::string sentence);
	void moveSequence(int stepId, int id);
	void grabObject(int stepId);
	void dropObject(int stepId);
	void feedbackImitationObject(int stepId, bool good);
	void feedbackImitationMove(int stepId, bool good);
	void feedbackTTWaiting(int stepId, bool good);
	void feedbackTTSorting(int stepId, bool good);
	void feedbackTTChoosing(int stepId, bool good);
	void feedbackTTPattern(int stepId, bool good);
	void feedbackJA(int stepId, bool good);
	void robotGoodMove(int stepId);
	void robotPointAtImage(int stepId, int imageId);
	void lookPointSay(int stepId, int direction);
	void lookPoint(int stepId, int direction, int actionId = _ACTION_LOOK_POINT_);
	void look(int stepId, int direction);
	void moveHead(float x, float y, float z, float speed, int stepId);
	void moveHand(bool rightArm, float x, float y, float z, float roll, int stepId);
	void getFromSandtrayReturn(std::string message);
	bool waitForAction(int stepId, int actionId, int& parameter);
	void purgeActionWaiter();
	bool waitForSandtray(std::vector<std::string> toMatch, std::vector<std::string>& parameter);
	void purgeSandtrayWaiter();
	bool waitForSensor(std::string name, bool value);
	void purgeSensorWaiter();
	int getCoordinatesImage(int imageId, std::vector<float>& goal);
	void waitAndSendFeedbackAction(int stepId, int waitingAction, int resolvingAction);
	bool getTherapist();
	void resetWaitingStates();

	std::vector<std::vector<float>> startBezier(std::vector<std::string> inputs);
	std::vector<float> getBezier(std::vector<std::vector<float>> points, float t);
	float getDistance(std::vector<float> p1, std::vector<float> p2);
	std::vector<float> pixelToRobotMove(std::vector<float> point);
	std::vector<float> pixelToRobotPoint(std::vector<float> point);


private:
	std::vector<ActionWaiter*> _actionWaiters;
	std::vector<SandtrayWaiter*> _sandtrayWaiters;
	std::vector<SensorWaiter*> _sensorWaiters;
	CommonFunctionalities* _common;
	bool _bIsInterrupted;
	bool _Btherapist;
	bool _Bdiagnose;
	int _iFallingReactionPrevious;
	int _iFaceExpressionPrevious;
	int _iSocialReactionPrevious;
	std::vector<std::string> _fallingSpeechSentences;
	std::vector<std::string> _positiveSpeechSentences;
	std::vector<std::string> _negativeSpeechSentences;
};

#endif
